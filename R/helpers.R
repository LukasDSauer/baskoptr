#' Generate an array of possible outcome scenarios
#'
#' This functions generates an array of possible outcome scenarios. Each row
#' of the array is a scenario vector. The array starts with `k` inactive
#' baskets and 0 active baskets and then increments in steps of `by` up to
#' `k` active baskets (or the next smaller multiple of `by`).
#'
#' @inheritParams baskwrap::setup_fujikawa_x
#'
#' @param p1 A numeric, the true response probability for the active baskets
#' @param by A numeric, increment of the scenario sequence, default: 1.
#'
#' @return A numeric array.
#' @export
#'
#' @examples
#' p1s <- get_p1s(k = 3, p0 = 0.2, p1 = 0.5)
get_p1s <- function(k, p0, p1, by = 1){
  steps <- c(0, seq(from = by, to = k, by = by))
  return(t(sapply(steps,
                function(times){
                  return(t(c(rep(p0, k - times),
                           rep(p1, times))))
                })))
}

#' Generate a scenario of possible outcomes
#'
#' A wrapper of `get_p1s()` that also returns the input values `k` and
#' `p0` as part of a list.
#'
#' @inheritParams get_p1s
#'
#' @return A list with components `k`, `p0` and `p1s`,
#' where `p1s` is generated by the the function `get_p1s`.
#' @export
#'
#' @examples
#' scenario <- get_scenarios(k = 3, p0 = 0.2, p1 = 0.5)
get_scenarios <- function(k, p0, p1, by = 1){
  return(list(k = k,
              p0 = p0,
              p1s = get_p1s(k, p0, p1, by)))
}

#' Internal helper function: Get details for two response scenarios
#'
#' @inheritParams u_ewp
#' @param which_details_list  A list of two lists, `which_details_list[["p1"]]`
#' and `which_details_list[["p2"]]`, containing the details which are to
#' be requested for `p1` and `p2`, respectively. `NULL` means that all will be
#' requested.
#' @return A list of two lists containing return values of `get_details` calls.
get_details_for_two_scenarios <- function(design, x, detail_params, p1, p2,
                                          which_details_list = NULL){
  detail_params <- io_val_p1(detail_params, p1)
  if(!is.null(which_details_list)){
    detail_params1 <- append_details(detail_params, "which_details",
                                    further = which_details_list[["p1"]])
  } else {
    detail_params1 <- set_details(detail_params, "which_details", "all")
  }
  details_p1 <- do.call(baskwrap::get_details,
                        c(design = list(design),
                          as.list(x),
                          detail_params1
                        ))

  # Calculate details under p2
  detail_params$p1 <- p2
  if(!is.null(which_details_list)){
    detail_params2 <- append_details(detail_params, "which_details",
                                     further = which_details_list[["p2"]])
  } else {
    detail_params2 <- set_details(detail_params, "which_details", "all")
  }
  details_p2 <- do.call(baskwrap::get_details,
                        c(design = list(design),
                          as.list(x),
                          detail_params2))
  return(list(p1 = details_p1,
              p2 = details_p2))
}


#' Internal helper function: Decide whether to record a trace and what path to
#' use
#'
#'
#' @param trace A parameter that can be `FALSE`, `TRUE` or a file path.
#' @param type A character that designates the name of the input.
#'
#' @return A list with components `rec` and `path`.
get_trace_info <- function(trace, type = "trace"){
  default_path <- paste0(type, "_tmp.RDS")
  trace_message <-
   paste('The', type , 'argument must be one of the following: A null object,
   a logical or character equal to an RDS file name or equal to "none",
   "report" or "report and save".')
  if(is.null(trace)){
    trace_rec <- "none"
    trace_path <- NULL
  } else if(is.logical(trace)){
    trace_rec <- ifelse(trace, "return", "none")
    trace_path <- NULL
    if(trace) trace_path <- default_path
  } else if(is.character(trace)){
    if(trace == ""){
      trace_rec <- "none"
      trace_path <- NULL
    } else if (trace == "none") {
      trace_rec <- "none"
      trace_path <- NULL
    } else if (trace == "return" | trace == "return and save") {
      trace_rec <- trace
      trace_path <- default_path
    } else if (substr(trace, nchar(trace) - 3, nchar(trace)) == ".RDS"){
      trace_rec <- "return and save"
      trace_path <- trace
    } else {
      stop(trace_message)
    }
  } else{
    stop(trace_message)
  }
  return(list(rec = trace_rec,
              path = trace_path))
}

#' Internal helper function: Append and set elements of a details list
#'
#' `append_details` takes the element `details[["index"]]` and appends it with
#' the list `further`. `set_details` takes the element `details[["index"]]` and
#' sets it to `value`.
#'
#' @param details A list of details to be requested from
#' `baskwrap::get_details.fujikawa_x` (will be supplied to the function as
#' the `which_details` argument).
#' @param index  Indicates which element of `details` should be appended.
#' @param further  A list of further parameters to be appended.
#' @param value A character string, `details[[index]]` will be assigned `value`.
#' @return The updated list of `details`.
append_details <- function(details, index, further){
  details[[index]] <- c(details[[index]], further)
  return(details)
}
#' @rdname append_details
set_details <- function(details, index, value){
  details[[index]] <- value
  return(details)
}


#' Internal helper function: Input validation for p1
#'
#' Returns `detail_params` with checked element `detail_params$p1 <- p1`,
#' depending on whether `p1` is not `NULL` or `detail_params$p1` is not `NULL`.
#' Returns an error message if both are NULL.
#'
#' @inheritParams u_ewp
#'
#' @return The updated list of `detail_params`.
io_val_p1 <- function(detail_params, p1){
  # Calculate details under p1
  if(!is.null(p1)){
    detail_params$p1 <- p1
  } else if(is.null(detail_params$p1)){
    stop("You must supply either p1 or detail_params$p1!")
  }
  return(detail_params)
}
